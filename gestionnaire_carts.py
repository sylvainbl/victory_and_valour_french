"""
Gestionnaire de cartes Victory & Valour
=======================================

Ce programme permet de :
- Charger les cartes extraites du PDF (cards.ipynb)
- M√©langer la pioche de mani√®re secr√®te
- Distribuer une main au joueur
- G√©rer la pioche et la d√©fausse
- Permettre au joueur de piocher ou se d√©fausser
- Organiser les cartes dans 3 dossiers : main, d√©fausse, pioche

Usage:
    python gestionnaire_cartes.py
"""

import os
import random
import json
import shutil
from typing import List, Optional


class Carte:
    """Repr√©sente une carte individuelle"""

    def __init__(self, numero: int, nom_fichier: str):
        self.numero = numero
        self.nom_fichier = nom_fichier
        self.chemin = None

    def __str__(self):
        return f"Carte {self.numero}"

    def __repr__(self):
        return f"Carte({self.numero}, '{self.nom_fichier}')"


class GestionnaireCartes:
    """Gestionnaire principal pour les cartes Victory & Valour"""

    def __init__(self, dossier_cartes: str = "cartes_individuelles"):
        self.dossier_cartes = dossier_cartes
        self.dossier_main = "main"
        self.dossier_defausse = "defausse"
        self.dossier_pioche = "pioche"

        self.toutes_cartes: List[Carte] = []
        self.pioche: List[Carte] = []
        self.main_joueur: List[Carte] = []
        self.defausse: List[Carte] = []
        self.seed_melange: Optional[int] = None

    def creer_dossiers_jeu(self) -> None:
        """Cr√©e les dossiers pour organiser les cartes"""
        dossiers = [self.dossier_main, self.dossier_defausse, self.dossier_pioche]

        for dossier in dossiers:
            if os.path.exists(dossier):
                shutil.rmtree(dossier)
            os.makedirs(dossier)

        print("üìÅ Dossiers de jeu cr√©√©s : main, d√©fausse, pioche")

    def copier_carte_vers_dossier(self, carte: Carte, dossier_destination: str) -> bool:
        """
        Copie une carte vers un dossier sp√©cifique

        Args:
            carte: La carte √† copier
            dossier_destination: Le dossier de destination

        Returns:
            bool: True si la copie s'est bien pass√©e
        """
        if not carte.chemin or not os.path.exists(carte.chemin):
            print(f"‚ö†Ô∏è  Fichier source introuvable pour {carte}")
            return False

        chemin_destination = os.path.join(dossier_destination, carte.nom_fichier)

        try:
            shutil.copy2(carte.chemin, chemin_destination)
            return True
        except Exception as e:
            print(f"‚ùå Erreur lors de la copie de {carte} : {e}")
            return False

    def organiser_cartes_dans_dossiers(self) -> None:
        """Organise toutes les cartes dans leurs dossiers respectifs"""
        print("üóÇÔ∏è  Organisation des cartes dans les dossiers...")

        # Vider les dossiers
        for dossier in [self.dossier_main, self.dossier_defausse, self.dossier_pioche]:
            if os.path.exists(dossier):
                for fichier in os.listdir(dossier):
                    os.remove(os.path.join(dossier, fichier))

        # Copier les cartes de la pioche
        for carte in self.pioche:
            self.copier_carte_vers_dossier(carte, self.dossier_pioche)

        # Copier les cartes de la main
        for carte in self.main_joueur:
            self.copier_carte_vers_dossier(carte, self.dossier_main)

        # Copier les cartes de la d√©fausse
        for carte in self.defausse:
            self.copier_carte_vers_dossier(carte, self.dossier_defausse)

        print(f"  ‚úÖ {len(self.pioche)} cartes copi√©es dans '{self.dossier_pioche}'")
        print(f"  ‚úÖ {len(self.main_joueur)} cartes copi√©es dans '{self.dossier_main}'")
        print(
            f"  ‚úÖ {len(self.defausse)} cartes copi√©es dans '{self.dossier_defausse}'"
        )

    def charger_cartes(self) -> bool:
        """
        Charge toutes les cartes depuis le dossier.

        Returns:
            bool: True si le chargement s'est bien pass√©
        """
        if not os.path.exists(self.dossier_cartes):
            print(f"‚ùå Erreur : Le dossier '{self.dossier_cartes}' n'existe pas.")
            print("   Ex√©cutez d'abord l'extracteur de cartes.")
            return False

        print(f"üìÅ Chargement des cartes depuis '{self.dossier_cartes}'...")

        cartes_trouvees = []

        # Chercher les cartes num√©rot√©es de 1 √† 54
        for numero in range(1, 55):
            nom_fichier = f"{numero}.png"
            chemin_complet = os.path.join(self.dossier_cartes, nom_fichier)

            if os.path.exists(chemin_complet):
                carte = Carte(numero, nom_fichier)
                carte.chemin = chemin_complet
                cartes_trouvees.append(carte)
            else:
                print(f"‚ö†Ô∏è  Carte {numero} manquante : {nom_fichier}")

        self.toutes_cartes = cartes_trouvees
        print(f"‚úÖ {len(self.toutes_cartes)} cartes charg√©es sur 54 attendues")

        if len(self.toutes_cartes) == 0:
            print(
                "‚ùå Aucune carte trouv√©e. V√©rifiez que l'extraction s'est bien pass√©e."
            )
            return False

        # Cr√©er les dossiers de jeu
        self.creer_dossiers_jeu()

        return True

    def melanger_pioche(self, seed: Optional[int] = None) -> None:
        """
        M√©lange secr√®tement toutes les cartes pour cr√©er la pioche.

        Args:
            seed: Graine pour le m√©lange (optionnel, pour reproductibilit√©)
        """
        if seed is None:
            seed = random.randint(1, 1000000)

        self.seed_melange = seed

        # Copier toutes les cartes dans la pioche
        self.pioche = self.toutes_cartes.copy()

        # M√©langer avec la graine
        random.seed(seed)
        random.shuffle(self.pioche)

        print(f"üîÄ Pioche m√©lang√©e secr√®tement ({len(self.pioche)} cartes)")
        print(f"   Seed de m√©lange : {seed} (gard√© secret)")

        # Organiser les cartes dans les dossiers
        self.organiser_cartes_dans_dossiers()

    def distribuer_main_initiale(self, nombre_cartes: int = 7) -> bool:
        """
        Distribue une main initiale au joueur.

        Args:
            nombre_cartes: Nombre de cartes √† distribuer

        Returns:
            bool: True si la distribution s'est bien pass√©e
        """
        if len(self.pioche) < nombre_cartes:
            print(
                f"‚ùå Pas assez de cartes dans la pioche pour distribuer {nombre_cartes} cartes"
            )
            return False

        self.main_joueur = []

        for _ in range(nombre_cartes):
            carte = self.pioche.pop(0)  # Piocher du dessus
            self.main_joueur.append(carte)

        # Trier la main par num√©ro pour faciliter la visualisation
        self.main_joueur.sort(key=lambda c: c.numero)

        print(f"üé¥ Main initiale distribu√©e : {nombre_cartes} cartes")

        # R√©organiser les cartes dans les dossiers
        self.organiser_cartes_dans_dossiers()

        return True

    def afficher_main(self) -> None:
        """Affiche la main du joueur"""
        if not self.main_joueur:
            print("üé¥ Main vide")
            return

        print(f"\nüé¥ Main du joueur ({len(self.main_joueur)} cartes):")
        for i, carte in enumerate(self.main_joueur):
            print(f"  {i + 1}. {carte}")

    def afficher_statuts(self) -> None:
        """Affiche l'√©tat g√©n√©ral du jeu"""
        print(f"\nüìä √âtat du jeu:")
        print(
            f"  üìö Pioche: {len(self.pioche)} cartes (dossier: {self.dossier_pioche})"
        )
        print(
            f"  üé¥ Main: {len(self.main_joueur)} cartes (dossier: {self.dossier_main})"
        )
        print(
            f"  üóëÔ∏è  D√©fausse: {len(self.defausse)} cartes (dossier: {self.dossier_defausse})"
        )

        if self.defausse:
            print(f"     Dessus de la d√©fausse: {self.defausse[-1]}")

    def piocher_carte(self) -> bool:
        """
        Le joueur pioche une carte du dessus de la pioche.

        Returns:
            bool: True si la pioche s'est bien pass√©e
        """
        if not self.pioche:
            print("‚ùå La pioche est vide !")
            return False

        carte_piochee = self.pioche.pop(0)  # Prendre le dessus de la pioche
        self.main_joueur.append(carte_piochee)

        # Trier la main
        self.main_joueur.sort(key=lambda c: c.numero)

        print(f"‚úÖ Vous avez pioch√© : {carte_piochee}")

        # R√©organiser les cartes dans les dossiers
        self.organiser_cartes_dans_dossiers()

        return True

    def defausser_carte(self, index_carte: int) -> bool:
        """
        Le joueur se d√©fausse d'une carte de sa main.

        Args:
            index_carte: Index de la carte dans la main (1-based)

        Returns:
            bool: True si la d√©fausse s'est bien pass√©e
        """
        if not self.main_joueur:
            print("‚ùå Votre main est vide !")
            return False

        if index_carte < 1 or index_carte > len(self.main_joueur):
            print(f"‚ùå Index invalide. Choisissez entre 1 et {len(self.main_joueur)}")
            return False

        carte_defaussee = self.main_joueur.pop(index_carte - 1)  # Convertir en 0-based
        self.defausse.append(carte_defaussee)  # Ajouter au dessus de la d√©fausse

        print(f"üóëÔ∏è  Vous avez d√©fauss√© : {carte_defaussee}")

        # R√©organiser les cartes dans les dossiers
        self.organiser_cartes_dans_dossiers()

        return True

    def sauvegarder_partie(self, nom_fichier: str = "sauvegarde_partie.json") -> bool:
        """
        Sauvegarde l'√©tat de la partie.

        Args:
            nom_fichier: Nom du fichier de sauvegarde

        Returns:
            bool: True si la sauvegarde s'est bien pass√©e
        """
        try:
            etat = {
                "seed_melange": self.seed_melange,
                "pioche": [carte.numero for carte in self.pioche],
                "main_joueur": [carte.numero for carte in self.main_joueur],
                "defausse": [carte.numero for carte in self.defausse],
            }

            with open(nom_fichier, "w", encoding="utf-8") as f:
                json.dump(etat, f, indent=2, ensure_ascii=False)

            print(f"üíæ Partie sauvegard√©e dans '{nom_fichier}'")
            return True

        except Exception as e:
            print(f"‚ùå Erreur lors de la sauvegarde : {e}")
            return False

    def charger_partie(self, nom_fichier: str = "sauvegarde_partie.json") -> bool:
        """
        Charge une partie sauvegard√©e.

        Args:
            nom_fichier: Nom du fichier de sauvegarde

        Returns:
            bool: True si le chargement s'est bien pass√©
        """
        if not os.path.exists(nom_fichier):
            print(f"‚ùå Fichier de sauvegarde '{nom_fichier}' introuvable")
            return False

        try:
            with open(nom_fichier, "r", encoding="utf-8") as f:
                etat = json.load(f)

            # Reconstruire les listes de cartes
            self.seed_melange = etat.get("seed_melange")

            self.pioche = [self.trouver_carte(num) for num in etat["pioche"]]
            self.main_joueur = [self.trouver_carte(num) for num in etat["main_joueur"]]
            self.defausse = [self.trouver_carte(num) for num in etat["defausse"]]

            print(f"üìÇ Partie charg√©e depuis '{nom_fichier}'")

            # R√©organiser les cartes dans les dossiers
            self.organiser_cartes_dans_dossiers()

            return True

        except Exception as e:
            print(f"‚ùå Erreur lors du chargement : {e}")
            return False

    def trouver_carte(self, numero: int) -> Carte:
        """Trouve une carte par son num√©ro"""
        for carte in self.toutes_cartes:
            if carte.numero == numero:
                return carte
        # Si pas trouv√©e, cr√©er une carte temporaire
        return Carte(numero, f"{numero}.png")


def menu_principal(gestionnaire: GestionnaireCartes) -> None:
    """Interface utilisateur en mode texte"""

    while True:
        print("\n" + "=" * 50)
        print("üé¥ GESTIONNAIRE DE CARTES VICTORY & VALOUR")
        print("=" * 50)

        gestionnaire.afficher_statuts()
        gestionnaire.afficher_main()

        print("\nüéØ Actions disponibles:")
        print("  1. Piocher une carte")
        print("  2. Se d√©fausser d'une carte")
        print("  3. Sauvegarder la partie")
        print("  4. Charger une partie")
        print("  5. Recommencer (nouveau m√©lange)")
        print("  6. R√©organiser les cartes dans les dossiers")
        print("  0. Quitter")

        try:
            choix = input("\nüëâ Votre choix : ").strip()

            if choix == "0":
                print("üëã Au revoir !")
                break

            elif choix == "1":
                gestionnaire.piocher_carte()

            elif choix == "2":
                if gestionnaire.main_joueur:
                    try:
                        index = int(
                            input(
                                f"Quelle carte d√©fausser ? (1-{len(gestionnaire.main_joueur)}) : "
                            )
                        )
                        gestionnaire.defausser_carte(index)
                    except ValueError:
                        print("‚ùå Veuillez entrer un nombre valide")
                else:
                    print("‚ùå Votre main est vide !")

            elif choix == "3":
                gestionnaire.sauvegarder_partie()

            elif choix == "4":
                if gestionnaire.charger_partie():
                    print("‚úÖ Partie charg√©e avec succ√®s !")

            elif choix == "5":
                print("üîÑ Nouveau m√©lange...")
                gestionnaire.melanger_pioche()
                gestionnaire.main_joueur = []
                gestionnaire.defausse = []
                gestionnaire.distribuer_main_initiale()

            elif choix == "6":
                print("üóÇÔ∏è  R√©organisation des cartes...")
                gestionnaire.organiser_cartes_dans_dossiers()
                print("‚úÖ Cartes r√©organis√©es dans les dossiers !")

            else:
                print("‚ùå Choix invalide")

        except KeyboardInterrupt:
            print("\n\nüëã Au revoir !")
            break
        except Exception as e:
            print(f"‚ùå Erreur : {e}")


def main():
    """Fonction principale"""
    print("üéÆ D√©marrage du gestionnaire de cartes Victory & Valour")

    # Cr√©er le gestionnaire
    gestionnaire = GestionnaireCartes()

    # Charger les cartes
    if not gestionnaire.charger_cartes():
        return

    # M√©langer et distribuer
    gestionnaire.melanger_pioche()

    if not gestionnaire.distribuer_main_initiale():
        return

    # Lancer l'interface
    menu_principal(gestionnaire)


if __name__ == "__main__":
    main()
